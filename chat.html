<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Chat del Hotel</title>

  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-storage-compat.js"></script>

  <!-- UI libs -->
  <script src="https://cdn.tailwindcss.com"></script>
<script src="https://unpkg.com/lucide@0.292.0/dist/umd/lucide.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">

  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ['Manrope','system-ui','-apple-system','Segoe UI','Roboto','sans-serif'] },
          boxShadow: { soft: '0 6px 22px rgba(0,0,0,.08)' }
        }
      }
    }
  </script>

  <style>
:root {
  --chat-primary:#111111;
  --assistant-text:#000000; /* üÜï color del texto del asistente */
  --chat-client-text:#ffffff;
  --chat-header-text:#1f2937;
  --avatar-radius:50%;
}
    html,body { height:100%; background:#ececec; }
    body { font-family: Manrope, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; -webkit-tap-highlight-color: transparent; }
    /* Contenedor principal del chat (ocupando todo el iframe/p√°gina) */
    #chatWindow {
      position: fixed; inset: 0; background:#ececec;
      display:flex; flex-direction:column; z-index: 9999;
      height: 100dvh; opacity:1; transform:none;
    }
    /* Header fijo */
    #chatHeader { position: sticky; top:0; z-index:10; }
    /* Scroll mensajes */
    #chatBox { flex:1; overflow-y:auto; -webkit-overflow-scrolling:touch; padding:12px 16px 16px; }
    /* Footer input fijo */
    #chatFooter { position: sticky; bottom:0; z-index:10;padding:12px 16px calc(12px + env(safe-area-inset-bottom)); }
    /* Burbujas */
    .chat-bubble { max-width: 86%; font-size:15px; line-height:1.45; }
    .chat-assistant { display:flex; align-items:flex-start; gap:10px; background:transparent; }
.chat-assistant .msg {
  background:#fff;
  border-radius:14px;
  padding:10px 14px;
  box-shadow:0 1px 3px rgba(0,0,0,.08);
  color: var(--assistant-text);
}
    .chat-user { margin-left:auto; color:var(--chat-client-text, #fff); background:var(--chat-primary); border-radius:14px; padding:10px 14px; }
    /* Enlaces dentro de mensajes */
    .chat-bubble a:not(.pill-btn) { color:#0a66ff; text-decoration:underline; }
    .chat-bubble a:not(.pill-btn):hover { text-decoration:none; }
    /* Bot√≥n enviar */
    #sendChatBtn { flex-shrink:0; width:40px; height:40px; border-radius:9999px; display:flex; align-items:center; justify-content:center; background:#000; color:#fff; }
    /* Color din√°mico aplicado tambi√©n al nombre del hotel */
    #chatHeader { color: var(--chat-header-text, #1f2937); }
    #chatHotelName { color: var(--chat-header-text, var(--chat-primary)) !important; }
    #chatMenuBtn,
    #chatHeader button { color: var(--chat-header-text, #1f2937) !important; }
    #chatHeader button svg,
    #chatHeader svg { color: inherit !important; stroke: currentColor !important; }
    /* Avatar asistente dentro de mensaje */
    .avatar-icon { width:36px; height:36px; border-radius:var(--avatar-radius, 50%); object-fit:cover; margin-top:2px; flex-shrink:0; box-shadow:0 1px 3px rgba(0,0,0,.1); }
    /* Cards (autoResponses tipo cards) */
    .cards { display:flex; gap:12px; overflow-x:auto; padding:2px; }
    .card {
      flex:0 0 260px; background:#fff; border-radius:14px; box-shadow:0 1px 3px rgba(0,0,0,.08);
      border:1px solid #eaeaea; overflow:hidden;
    }
    .card img { width:100%; height:140px; object-fit:cover; display:block; }
    .card .in { padding:10px 12px; }
    .card .title { font-weight:700; font-size:15px; }
    .card .sub { font-size:13px; color:#555; margin-top:2px; }
    .pill-btn {
      display:inline-block; margin-top:8px; border:1.5px solid var(--chat-primary);
      color:var(--chat-primary); border-radius:9999px; padding:6px 10px; font-size:12px;
    }
    .pill-btn:hover { background:var(--chat-primary); color:#fff; }
    .chat-bubble .pill-btn {
      color:inherit;
      border-color:currentColor;
      text-decoration:none;
    }
    .chat-bubble .pill-btn:hover {
      background:var(--chat-primary);
      border-color:var(--chat-primary);
      color:#fff;
      text-decoration:none;
    }
    /* Input */
    #chatInput {
      flex:1; background:#fff; border:1px solid #ddd; border-radius:10px; padding:10px 14px; font-size:16px;
      outline:none; box-shadow:0 0 4px 1px #02243114; transition: box-shadow .2s;
    }
    #chatInput:focus { box-shadow:0 0 6px 1px #02243126; }

    .dot {
  width: 6px;
  height: 6px;
  background-color: #888; /* puedes cambiar el color */
  border-radius: 50%;
  display: inline-block;
  animation: blink 1.2s infinite;
}

.dot:nth-child(2) { animation-delay: 0.2s; }
.dot:nth-child(3) { animation-delay: 0.4s; }

@keyframes blink {
  0%, 80%, 100% { opacity: 0.3; }
  40% { opacity: 1; }
}

  </style>
</head>
<body>
  <!-- VISTA DEL CHAT (siempre visible, sin hero ni men√∫s) -->
  <div id="chatWindow">
    <!-- Header -->
    <div id="chatHeader" class="bg-white flex items-center justify-between px-4 py-4">
      <div class="flex items-center gap-3">
        <img id="chatLogo" class="w-9 h-9 rounded-full shadow hidden" alt="Logo">
        <span id="chatHotelName" class="font-semibold text-[17px] text-gray-800">Tomos Bot</span>
      </div>
      <div class="flex items-center gap-4">
        <div class="relative">
          <button id="chatMenuBtn" type="button" class="text-gray-500 select-none cursor-pointer flex items-center justify-center w-8 h-8 rounded-full hover:bg-gray-100" title="Men√∫" aria-haspopup="true" aria-expanded="false">‚Ä¢‚Ä¢‚Ä¢</button>
          <div id="chatMenu" class="hidden absolute right-0 mt-2 w-56 bg-white rounded-lg shadow-lg border border-gray-100 py-1 text-sm z-20">
            <button id="downloadChatBtn" type="button" class="w-full px-3 py-2 text-left text-gray-700 hover:bg-gray-100 flex items-center gap-2">
              <i data-lucide="download" class="w-4 h-4"></i>
              <span>Download conversation</span>
            </button>
          </div>
        </div>
        <button id="closeChat" class="text-gray-400 hover:text-gray-600" title="Cerrar">
          <i data-lucide="x" class="w-5 h-5"></i>
        </button>
      </div>
    </div>

    <!-- Mensajes -->
    <div id="chatBox" class="flex flex-col gap-3"></div>

    <!-- Footer -->
    <div id="chatFooter" class="flex items-center gap-3">
      <input id="chatInput" type="text" placeholder="√âcrivez votre message‚Ä¶" />
      <button id="sendChatBtn"><i data-lucide="send" class="w-5 h-5"></i></button>
    </div>

<div class="flex justify-center items-center py-2">
  <a href="https://tomos.bot" target="_blank" rel="noopener noreferrer" 
     class="flex items-center gap-2 text-gray-500 text-xs">
    <span>Powered by</span>
    <img src="logo.svg" alt="Tomos Bot" class="h-4" style="height:16px; width:auto;" />
  </a>
</div>


  </div>

  <script>
    let USER_LANGUAGE = 'en';
    const I18N = {
      es: {
        leaveEmail: 'Dejar email',
        leavePhone: 'Dejar tel√©fono',
        noThanks: 'No gracias',
        askName: '¬øCu√°l es tu nombre?',
        askEmail: 'Perfecto, ahora escribe tu correo electr√≥nico:',
        askPhone: 'Perfecto, ahora escribe tu n√∫mero de contacto:',
        invalidEmail: 'Parece que el correo no es v√°lido. ¬øPuedes intentarlo nuevamente?',
        invalidPhone: 'Ese n√∫mero no parece v√°lido. Por favor ingr√©salo nuevamente con c√≥digo de pa√≠s si es posible.',
        thankYou: '¬°Gracias! Un asesor te contactar√° pronto.'
      },
      en: {
        leaveEmail: 'Leave email',
        leavePhone: 'Leave phone',
        noThanks: 'No thanks',
        askName: "What's your name?",
        askEmail: 'Great, now type your email address:',
        askPhone: 'Great, now type your contact number:',
        invalidEmail: "It seems that email isn't valid. Could you try again?",
        invalidPhone: "That number doesn't look valid. Please enter it again with country code if possible.",
        thankYou: 'Thanks! An advisor will contact you soon.'
      },
      fr: {
        leaveEmail: 'Laisser un e-mail',
        leavePhone: 'Laisser un t√©l√©phone',
        noThanks: 'Non merci',
        askName: 'Quel est ton nom ?',
        askEmail: 'Parfait, √©cris maintenant ton adresse e-mail :',
        askPhone: 'Parfait, √©cris maintenant ton num√©ro de contact :',
        invalidEmail: "Il semble que cet e-mail n'est pas valide. Peux-tu r√©essayer ?",
        invalidPhone: "Ce num√©ro ne semble pas valide. Merci de le saisir √† nouveau avec l'indicatif si possible.",
        thankYou: 'Merci ! Un conseiller te contactera bient√¥t.'
      },
      de: {
        leaveEmail: 'E-Mail hinterlassen',
        leavePhone: 'Telefonnummer hinterlassen',
        noThanks: 'Nein danke',
        askName: 'Wie hei√üt du?',
        askEmail: 'Perfekt, gib jetzt deine E-Mail-Adresse ein:',
        askPhone: 'Perfekt, gib jetzt deine Kontaktnummer ein:',
        invalidEmail: 'Diese E-Mail scheint nicht g√ºltig zu sein. Kannst du es noch einmal versuchen?',
        invalidPhone: 'Diese Nummer scheint nicht g√ºltig zu sein. Bitte gib sie erneut mit L√§ndervorwahl ein, wenn m√∂glich.',
        thankYou: 'Danke! Ein Berater wird dich bald kontaktieren.'
      },
      pl: {
        leaveEmail: 'Podaj e-mail',
        leavePhone: 'Podaj telefon',
        noThanks: 'Nie, dziƒôkujƒô',
        askName: 'Jak masz na imiƒô?',
        askEmail: '≈öwietnie, teraz wpisz sw√≥j adres e-mail:',
        askPhone: '≈öwietnie, teraz wpisz sw√≥j numer kontaktowy:',
        invalidEmail: 'WyglƒÖda na to, ≈ºe ten e-mail jest nieprawid≈Çowy. Czy mo≈ºesz spr√≥bowaƒá ponownie?',
        invalidPhone: 'Ten numer wyglƒÖda na nieprawid≈Çowy. Wpisz go ponownie z kodem kraju, je≈õli to mo≈ºliwe.',
        thankYou: 'Dziƒôkujemy! Wkr√≥tce skontaktuje siƒô z TobƒÖ doradca.'
      }
    };
    document.addEventListener('DOMContentLoaded', () => {
      const BROWSER_LANGUAGE = (navigator.language || navigator.userLanguage || 'en').slice(0, 2).toLowerCase();
      const TEXT_TRANSLATIONS = {
        es: {
          inputPlaceholder: 'Escribe tu mensaje‚Ä¶',
          downloadConversation: 'Descargar conversaci√≥n'
        },
        en: {
          inputPlaceholder: 'Write your message‚Ä¶',
          downloadConversation: 'Download conversation'
        },
        fr: {
          inputPlaceholder: '√âcrivez votre message‚Ä¶',
          downloadConversation: 'T√©l√©charger la conversation'
        }
      };

      const selected = TEXT_TRANSLATIONS[BROWSER_LANGUAGE] || TEXT_TRANSLATIONS.en;

      const chatInput = document.getElementById('chatInput');
      if (chatInput) {
        chatInput.placeholder = selected.inputPlaceholder;
      }

      USER_LANGUAGE = BROWSER_LANGUAGE;

      const downloadChatBtnLabel = document.querySelector('#downloadChatBtn span');
      if (downloadChatBtnLabel) {
        downloadChatBtnLabel.textContent = selected.downloadConversation;
      }
    });
  </script>

  <script>
/* =========================
   FIREBASE CONFIG
========================= */
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyC2c3S_NtouIjHPrk5LM5c0DQoTWyBrzH4",
  authDomain: "timbre-c9547.firebaseapp.com",
  databaseURL: "https://timbre-c9547-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "timbre-c9547",
  storageBucket: "timbre-c9547.firebasestorage.app",
  messagingSenderId: "127064655657",
  appId: "1:127064655657:web:a4e99dcbc6ab33f32c1938"
};

let app;
let db;

try {
  app = firebase.app(); // reuse existing app if already initialized
} catch (e) {
  app = firebase.initializeApp(FIREBASE_CONFIG);
}
db = firebase.database(app);

function dbRef(path) {
  return db.ref(path);
}

function getEmpresa(){
  const url = new URL(window.location.href);
  const p = (url.searchParams.get('empresa') || localStorage.getItem('empresa') || 'Boletum').trim();
  localStorage.setItem('empresa', p);
  return p;
}
let EMPRESA = getEmpresa();

function getBot() {
  const url = new URL(window.location.href);
  const storageKey = `bot:${EMPRESA}`;
  const raw = (url.searchParams.get('bot') || localStorage.getItem(storageKey) || 'default').trim();
  const bot = raw || 'default';
  localStorage.setItem(storageKey, bot);
  return bot;
}
let BOT = getBot();

const CHAT_SESSION_KEY = `chatId:${EMPRESA}:${BOT}`;
let CHAT_ID = sessionStorage.getItem(CHAT_SESSION_KEY) || `${Date.now()}`;
sessionStorage.setItem(CHAT_SESSION_KEY, CHAT_ID);

const chatLogBaseRef = dbRef(`empresas/${EMPRESA}/bots/${BOT}/conversaciones/${CHAT_ID}`);
const chatMessagesRef = chatLogBaseRef.child('messages');
const chatMetaRef = chatLogBaseRef.child('meta');
let chatMetaCache = null;
let chatStartedAt = null;
const conversationLog = []; // {sender:'bot'|'user', text:string, time:number}
const pendingMessagesQueue = [];
let hasUserSentMessage = false;

let leadPromptShown = false;
let leadCaptureState = null;
let leadCaptureCompleted = false;
const LEAD_SUMMARY_LANGUAGES = ['es', 'en', 'fr', 'pl', 'de'];

let SYSTEM_PROMPT = "";
let systemPromptRef = null;

chatMetaRef.once('value').then(snapshot => {
  chatMetaCache = snapshot.val() || {};
  if (chatMetaCache.startedAt) {
    chatStartedAt = chatMetaCache.startedAt;
  }
}).catch(err => console.warn('No se pudo cargar la metadata del chat', err));

function getChatUserName() {
  const candidates = [
    `chatUserName:${EMPRESA}:${BOT}`,
    'chatUserName',
    'userName',
    'guestName',
    'name'
  ];
  for (const key of candidates) {
    const fromSession = sessionStorage.getItem(key);
    if (fromSession && fromSession.trim()) return fromSession.trim();
    const fromLocal = localStorage.getItem(key);
    if (fromLocal && fromLocal.trim()) return fromLocal.trim();
  }
  return 'Guest';
}

function stripHtml(html) {
  const tmp = document.createElement('div');
  tmp.innerHTML = html || '';
  return tmp.textContent || tmp.innerText || '';
}

function updateChatMeta(lastMessage, timestamp) {
  if (!chatMetaRef) return;
  const updates = {
    userName: getChatUserName(),
    lastMessage: lastMessage || '',
    lastUpdated: timestamp
  };
  if (!chatStartedAt) {
    chatStartedAt = chatMetaCache?.startedAt || timestamp;
  }
  if (!chatMetaCache?.startedAt) {
    updates.startedAt = chatStartedAt;
  }
  chatMetaRef.update(updates).then(() => {
    chatMetaCache = { ...(chatMetaCache || {}), ...updates };
  }).catch(err => console.warn('No se pudo actualizar la metadata del chat', err));
}

function persistChatPayload(payload) {
  if (!chatMessagesRef || !payload) return;
  try {
    const newRef = chatMessagesRef.push();
    newRef.set(payload).catch(err => console.warn('No se pudo guardar el mensaje del chat', err));
  } catch (err) {
    console.warn('No se pudo registrar la referencia del mensaje', err);
  }
  updateChatMeta(payload.text, payload.time);
}

function flushPendingMessages() {
  if (!pendingMessagesQueue.length) return;
  while (pendingMessagesQueue.length) {
    const pending = pendingMessagesQueue.shift();
    persistChatPayload(pending);
  }
}

function logChatMessage(sender, text) {
  if (!chatMessagesRef || !sender) return;
  const now = Date.now();
  const safeText = text == null ? '' : String(text);
  const payload = {
    sender,
    text: safeText,
    time: now
  };
  conversationLog.push({ sender, text: safeText, time: now });
  const isUserMessage = sender === 'user' && safeText.trim().length > 0;
  if (!hasUserSentMessage) {
    if (isUserMessage) {
      hasUserSentMessage = true;
      flushPendingMessages();
      persistChatPayload(payload);
    } else {
      pendingMessagesQueue.push(payload);
    }
    return;
  }
  persistChatPayload(payload);
}

function initSystemPromptListener() {
  if (systemPromptRef) {
    try {
      systemPromptRef.off();
    } catch (err) {
      console.warn('No se pudo desuscribir del prompt anterior', err);
    }
    systemPromptRef = null;
  }

  if (!EMPRESA || !BOT) {
    SYSTEM_PROMPT = "";
    return;
  }

  systemPromptRef = db.ref(`empresas/${EMPRESA}/bots/${BOT}/config/prompt`);
  systemPromptRef.on('value', (snap) => {
    const value = snap.val();
    SYSTEM_PROMPT = typeof value === 'string' ? value : '';
  }, (err) => {
    console.warn('No se pudo cargar el prompt del sistema', err);
    SYSTEM_PROMPT = '';
  });
}

let useLegacyBotPath = false;
let botCollectionPath = null;

function getDefaultBotCollectionPath() {
  return `empresas/${EMPRESA}/bots`;
}

function getConfigBotCollectionPath() {
  return `empresas/${EMPRESA}/config/bots`;
}

function getLegacyBotCollectionPath() {
  return `${EMPRESA}/bots`;
}

function getBotBasePath() {
  if (botCollectionPath) {
    const basePath = botCollectionPath.startsWith('empresas/')
      ? botCollectionPath
      : `empresas/${botCollectionPath}`;
    return `${basePath}/${BOT}`;
  }
  return useLegacyBotPath ? `empresas/${EMPRESA}` : `empresas/${EMPRESA}/bots/${BOT}`;
}

function eref(path){ return db.ref(`${getBotBasePath()}/${path}`); }

async function prepareBotPath() {
  const candidates = [
    getDefaultBotCollectionPath(),
    getConfigBotCollectionPath(),
    getLegacyBotCollectionPath()
  ];

  for (const path of candidates) {
    try {
      await db.ref(`${path}/${BOT}`).once('value');
      botCollectionPath = path;
      useLegacyBotPath = false;
      return;
    } catch (err) {
      if (err?.code === 'PERMISSION_DENIED') {
        continue;
      }
      console.warn('No se pudo verificar la ruta del bot', path, err);
    }
  }

  try {
    const legacySnap = await db.ref(`empresas/${EMPRESA}`).once('value');
    if (legacySnap.exists()) {
      botCollectionPath = null;
      useLegacyBotPath = true;
      return;
    }
  } catch (err) {
    console.warn('No se pudo verificar la ruta legacy del bot', err);
  }

  botCollectionPath = getConfigBotCollectionPath();
  useLegacyBotPath = false;
}

/* =========================
   IA PROXY
   - Cambia PROXY_URL a tu endpoint (Vercel, etc.)
   - Tambi√©n puedes pasar ?proxy=https://tu-endpoint
========================= */
const urlParams = new URLSearchParams(location.search);
let PROXY_URL = urlParams.get('proxy') || "https://hotel-chat-proxy.vercel.app/api/chat";
// Espera respuesta JSON: { choices: [ { message: { content: "‚Ä¶" } } ] } (OpenAI-style)

/* =========================
   UI ELEMENTS
========================= */
const chatBox = document.getElementById('chatBox');
const input   = document.getElementById('chatInput');
const sendBtn = document.getElementById('sendChatBtn');
const hotelNameEl = document.getElementById('chatHotelName');
const chatLogo = document.getElementById('chatLogo');
const chatAvatarHead = document.getElementById('chatAvatarHead');
const chatMenuBtn = document.getElementById('chatMenuBtn');
const chatMenu = document.getElementById('chatMenu');
const downloadChatBtn = document.getElementById('downloadChatBtn');

function linkify(text){
  if (!text) return "";
  const urlRegex=/((https?:\/\/|www\.)[^\s]+|[a-zA-Z0-9-]+\.[a-z]{2,}(\/\S*)?)/gi;
  return text.replace(urlRegex, m=>{
    let u=m; if(!/^https?:\/\//i.test(u)) u="https://"+u;
    return `<a href="${u}" target="_blank" rel="noopener noreferrer">${m}</a>`;
  });
}

/* =========================
   RENDER MENSAJES
========================= */
function createAssistantBubble(avatarUrl) {
  const wrap = document.createElement('div');
  wrap.className = 'chat-bubble chat-assistant';
  const avatar = document.createElement('img');
  avatar.className = 'avatar-icon';
  if (avatarUrl) {
    avatar.src = avatarUrl;
  } else {
    avatar.style.display = 'none';
  }
  const msg = document.createElement('div');
  msg.className = 'msg';
  const assistantColor = getComputedStyle(document.documentElement)
    .getPropertyValue('--assistant-text') || '#000000';
  msg.style.color = assistantColor;
  wrap.appendChild(avatar);
  wrap.appendChild(msg);
  chatBox.appendChild(wrap);
  chatBox.scrollTop = chatBox.scrollHeight;
  return { wrap, msg };
}

function addAssistantMessageHTML(html, {avatarUrl, rawText}={}){
  const { msg } = createAssistantBubble(avatarUrl);
  msg.innerHTML = html;
  const plain = rawText != null ? rawText : stripHtml(html);
  logChatMessage('bot', plain);
}

function addAssistantMessage(text, opts={}){
  const { avatarUrl, animate = true } = opts;
  const content = text || "";
  if (!animate) {
    const md = marked.parse(content);
    addAssistantMessageHTML(md, { avatarUrl, rawText: content });
    return;
  }

  const { msg } = createAssistantBubble(avatarUrl);
  if (!content) {
    logChatMessage('bot', '');
    return;
  }

  let index = 0;
  const total = content.length;
  const baseDelay = 18;
  const minChunk = 1;
  const chunkSize = Math.max(minChunk, Math.ceil(total / 120));

  function typeNextChunk() {
    index = Math.min(total, index + chunkSize);
    const partial = content.slice(0, index);
    msg.innerHTML = marked.parse(partial);
    chatBox.scrollTop = chatBox.scrollHeight;
    if (index < total) {
      setTimeout(typeNextChunk, baseDelay);
    } else {
      logChatMessage('bot', content);
    }
  }

  typeNextChunk();
}
function addUserMessage(text){
  const bubble = document.createElement('div');
  bubble.className = 'chat-bubble chat-user';
  bubble.textContent = text;
  chatBox.appendChild(bubble);
  chatBox.scrollTop = chatBox.scrollHeight;
  logChatMessage('user', text);
}
function addTyping(){
  const el = document.createElement('div');
  el.className = 'chat-bubble chat-assistant';
  el.dataset.typing = '1';
  el.innerHTML = `
    <img class="avatar-icon" id="__typAva" />
    <div class="msg flex items-center gap-1">
      <span class="dot"></span>
      <span class="dot"></span>
      <span class="dot"></span>
    </div>
  `;
  chatBox.appendChild(el);
  chatBox.scrollTop = chatBox.scrollHeight;
  return el;
}

function removeTyping(el){ if(el && el.parentNode) el.parentNode.removeChild(el); }

function showTypingIndicator({ avatarUrl } = {}) {
  const typing = addTyping();
  const avatarImg = typing.querySelector('#__typAva');
  const avatar = avatarUrl || CURRENT.avatarUrl;
  if (avatarImg) {
    if (avatar) {
      avatarImg.src = avatar;
    } else {
      avatarImg.style.display = 'none';
    }
  }
  return typing;
}

function delayedAssistantAction(action, delayMs = 1800, opts = {}) {
  const typing = showTypingIndicator(opts);
  setTimeout(() => {
    removeTyping(typing);
    action();
  }, delayMs);
}

function getLeadRef(sessionId = CHAT_ID) {
  return dbRef(`empresas/${EMPRESA}/bots/${BOT}/leads/${sessionId}`);
}

function getFirstUserMessage() {
  for (const entry of conversationLog) {
    if (entry.sender === 'user' && entry.text) {
      return entry.text;
    }
  }
  return '';
}

function getLastUserMessage() {
  for (let i = conversationLog.length - 1; i >= 0; i -= 1) {
    const entry = conversationLog[i];
    if (entry.sender === 'user' && entry.text) {
      return entry.text;
    }
  }
  return '';
}

function getRecentUserMessages(limit = 5) {
  const messages = [];
  for (let i = conversationLog.length - 1; i >= 0 && messages.length < limit; i -= 1) {
    const entry = conversationLog[i];
    if (entry.sender === 'user' && entry.text) {
      messages.unshift(entry.text);
    }
  }
  return messages;
}

function buildLeadSummaryPrompt(languageCode, userMessagesBlock) {
  return `Genera un resumen muy breve (m√°ximo 6 palabras) que describa qu√© necesita el usuario seg√∫n los mensajes recientes del chat. \nEl resumen debe escribirse exclusivamente en el idioma especificado a continuaci√≥n.\n\nIdioma objetivo: ${languageCode}\n\nReglas:\n- No saludes.\n- No expliques nada.\n- No inventes informaci√≥n.\n- No repitas textualmente frases largas del usuario.\n- Tono profesional y claro.\n- Si el usuario solo pidi√≥ contacto sin dar contexto ("quiero que me contacten", "ll√°menme", "contacto"), devuelve exactamente: \n  - En espa√±ol: "Solicitud de contacto"\n  - En ingl√©s: "Contact request"\n  - En franc√©s: "Demande de contact"\n  - En polaco: "Pro≈õba o kontakt"\n  - En alem√°n: "Kontaktanfrage"\n\nDevuelve solamente el resumen.\n\nMensajes del usuario:\n${userMessagesBlock}`;
}

async function requestLeadSummary(prompt) {
  try {
    const res = await fetch(PROXY_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ messages: [{ role: 'user', content: prompt }] })
    });
    if (!res.ok) throw new Error('IA request failed: ' + res.status);
    const data = await res.json();
    return data?.choices?.[0]?.message?.content?.trim() || '';
  } catch (err) {
    console.warn('No se pudo generar el resumen del lead', err);
    return '';
  }
}

async function generateLeadSummariesFromAI() {
  const recentMessages = getRecentUserMessages(6);
  if (!recentMessages.length) return null;
  const userMessagesBlock = recentMessages.join('\n');
  const summaries = {};
  for (const languageCode of LEAD_SUMMARY_LANGUAGES) {
    const prompt = buildLeadSummaryPrompt(languageCode, userMessagesBlock);
    const summary = await requestLeadSummary(prompt);
    if (summary) {
      summaries[languageCode] = summary;
    }
  }
  return Object.keys(summaries).length ? summaries : null;
}

function renderLeadPrompt(promptText) {
  const translations = I18N[USER_LANGUAGE] || I18N.en;
  const leadText = (promptText || '').trim() || 'Para avanzar, ¬øquieres que un asesor te contacte?';
  const safeLeadText = leadText
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
  const html = `
    <div class="space-y-3">
      <p>${safeLeadText}</p>
      <div class="flex flex-wrap gap-2">
        <button class="pill-btn lead-option" data-lead-action="email">${translations.leaveEmail} </button>
        <button class="pill-btn lead-option" data-lead-action="phone">${translations.leavePhone}</button>
        <button class="pill-btn lead-option" data-lead-action="skip">${translations.noThanks}</button>
      </div>
    </div>
  `;
  addAssistantMessageHTML(html, { avatarUrl: CURRENT.avatarUrl, rawText: leadText });
}

async function generateLeadIntro(latestUserText) {
  const fallbackText = 'Para avanzar, ¬øquieres que un asesor te contacte?';
  const userMessage = (latestUserText || '').trim() || getLastUserMessage() || fallbackText;
  const prompt = `Genera una frase muy breve (m√°ximo 1 l√≠nea) invitando al usuario a dejar un medio de contacto. \nLa frase debe estar escrita EXCLUSIVAMENTE en el mismo idioma que el mensaje m√°s reciente del usuario.\nAd√°ptate al contexto de lo que dijo el usuario.\n\nReglas:\n- Detecta autom√°ticamente el idioma del usuario (puede ser cualquier idioma).\n- Responde √∫nicamente en ese idioma.\n- No mezcles idiomas.\n- No saludes.\n- No hagas preguntas largas.\n- No ofrezcas a√∫n opciones (solo la frase introductoria).\n- Mant√©n un tono amable, humano y profesional.\n- Si no puedes determinar con claridad el idioma, responde en ingl√©s.\n\nMensaje del usuario:\n${userMessage}`;
  const promptMessages = [
    {
      role: 'user',
      content: prompt
    }
  ];

  try {
    const res = await fetch(PROXY_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ messages: promptMessages })
    });

    if (!res.ok) throw new Error('IA request failed: ' + res.status);

    const data = await res.json();
    const generated = data?.choices?.[0]?.message?.content?.trim();
    return generated || fallbackText;
  } catch (err) {
    console.warn('No se pudo generar la frase de lead', err);
    return fallbackText;
  }
}

async function maybePromptLeadCaptureAI(latestUserText) {
  if (leadPromptShown || leadCaptureCompleted || leadCaptureState?.active) return false;

  const conversation = conversationLog
    .map(m => `${m.sender}: ${m.text}`)
    .join("\n");

  const leadDetected = await detectLeadIntent(conversation);
  if (leadDetected) {
    leadPromptShown = true;
    const introText = await generateLeadIntro(latestUserText);
    renderLeadPrompt(introText);
    return true;
  }
  return false;
}

function startLeadCapture(method) {
  const translations = I18N[USER_LANGUAGE] || I18N.en;
  leadCaptureState = {
    active: true,
    method,
    step: 'collect-name',
    name: '',
    email: '',
    phone: ''
  };
  addAssistantMessage(translations.askName, { avatarUrl: CURRENT.avatarUrl });
}

function handleLeadOption(action) {
  if (action === 'email' || action === 'phone') {
    startLeadCapture(action);
    return;
  }
  if (action === 'skip') {
    leadCaptureState = null;
    addAssistantMessage('Sin problema, seguimos üôÇ', { avatarUrl: CURRENT.avatarUrl });
  }
}

function validateEmail(value) {
  if (!value) return false;
  const trimmed = value.trim();
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(trimmed);
}

function validatePhone(value) {
  if (!value) return false;
  const trimmed = value.trim();
  return /^[+]?[-\d()\s]{6,}$/.test(trimmed);
}

async function saveLeadToFirebase(state) {
  if (!state || !state.name || !state.method) return Promise.resolve();
  const leadRef = getLeadRef();
  const timestamp = Date.now();
  const payload = {
    name: state.name,
    method: state.method,
    sessionId: CHAT_ID,
    timestamp,
    pageUrl: window.location.href
  };
  if (state.email) payload.email = state.email;
  if (state.phone) payload.phone = state.phone;
  if (USER_LANGUAGE) payload.language = USER_LANGUAGE;
  const firstMessage = getFirstUserMessage();
  const lastMessage = getLastUserMessage();
  if (firstMessage) payload.firstMessage = firstMessage;
  if (lastMessage) payload.lastMessage = lastMessage;
  if (state.email || state.phone) {
    const summaries = await generateLeadSummariesFromAI();
    if (summaries) {
      payload.note = summaries;
    }
  }
  return leadRef.update(payload).catch(err => {
    console.warn('No se pudo guardar el lead', err);
  });
}

function finalizeLeadCapture() {
  if (!leadCaptureState) return;
  const translations = I18N[USER_LANGUAGE] || I18N.en;
  const thankYou = translations.thankYou;
  addAssistantMessage(thankYou, { avatarUrl: CURRENT.avatarUrl });
  const snapshot = { ...leadCaptureState };
  leadCaptureState = null;
  leadCaptureCompleted = true;
  saveLeadToFirebase(snapshot);
}

function processLeadCaptureInput(text) {
  if (!leadCaptureState?.active) return false;
  const translations = I18N[USER_LANGUAGE] || I18N.en;
  const trimmed = (text || '').trim();
  if (!trimmed) return true;

  if (leadCaptureState.step === 'collect-name') {
    leadCaptureState.name = trimmed;
    leadCaptureState.step = leadCaptureState.method === 'email' ? 'collect-email' : 'collect-phone';
    const nextPrompt = leadCaptureState.method === 'email'
      ? translations.askEmail
      : translations.askPhone;
    addAssistantMessage(nextPrompt, { avatarUrl: CURRENT.avatarUrl });
    return true;
  }

  if (leadCaptureState.step === 'collect-email') {
    if (!validateEmail(trimmed)) {
      addAssistantMessage(translations.invalidEmail, { avatarUrl: CURRENT.avatarUrl });
      return true;
    }
    leadCaptureState.email = trimmed;
    leadCaptureState.active = false;
    leadCaptureState.step = 'completed';
    finalizeLeadCapture();
    return true;
  }

  if (leadCaptureState.step === 'collect-phone') {
    if (!validatePhone(trimmed)) {
      addAssistantMessage(translations.invalidPhone, { avatarUrl: CURRENT.avatarUrl });
      return true;
    }
    leadCaptureState.phone = trimmed;
    leadCaptureState.active = false;
    leadCaptureState.step = 'completed';
    finalizeLeadCapture();
    return true;
  }

  return true;
}

/* =========================
   AUTO RESPONSES (desde Admin beta3)
========================= */
let AUTO = {}; // { id: {trigger, type, text, cards, extras} }
function tryAutoResponse(userText){
  if (!userText || !AUTO) return false;
  const t = userText.toLowerCase();
  // Encuentra la primera coincidencia simple por "includes"
  const hit = Object.values(AUTO).find(r => (r.trigger||"").toLowerCase().trim() && t.includes(r.trigger.toLowerCase().trim()));
  if (!hit) return false;

  const delayOpts = { avatarUrl: CURRENT.avatarUrl };
  const delayMs = 2000;

  if (hit.type === 'text') {
    const parts = [];
    if (hit.extras?.image) parts.push(`<img src="${hit.extras.image}" class="w-full max-w-xs rounded-lg mb-2">`);
    if (hit.extras?.title) parts.push(`<div class="font-semibold">${hit.extras.title}</div>`);
    if (hit.extras?.subtitle) parts.push(`<div class="text-sm text-gray-600">${hit.extras.subtitle}</div>`);
    if (hit.text) parts.push(`<div class="mt-1">${linkify(marked.parseInline(hit.text))}</div>`);
    if (Array.isArray(hit.extras?.buttons) && hit.extras.buttons.length){
      parts.push(`<div class="mt-2 flex flex-wrap gap-2">` +
        hit.extras.buttons.filter(b=>b?.label).map(b=>{
          const href = b.link || "#";
          return `<a href="${href}" target="_blank" class="pill-btn">${b.label}</a>`;
        }).join("") + `</div>`);
    }
    const html = parts.join("");
    delayedAssistantAction(() => addAssistantMessageHTML(html, { avatarUrl: CURRENT.avatarUrl }), delayMs, delayOpts);
    return true;
  }

  if (hit.type === 'cards') {
    const cards = (hit.cards||[]).map(c=>`
      <div class="card">
        ${c.image ? `<img src="${c.image}" alt="">` : ``}
        <div class="in">
          ${c.title? `<div class="title">${c.title}</div>`:``}
          ${c.subtitle? `<div class="sub">${c.subtitle}</div>`:``}
          ${c.link ? `<a href="${c.link}" target="_blank" class="pill-btn">${c.buttonText||'Ver'}</a>` : ``}
        </div>
      </div>
    `).join("");
    const html = `<div class="cards">${cards}</div>`;
    delayedAssistantAction(() => addAssistantMessageHTML(html, { avatarUrl: CURRENT.avatarUrl }), delayMs, delayOpts);
    return true;
  }

  if (hit.type === 'menu') {
    const label = hit.text ? `<div class="mb-2">${hit.text}</div>` : '';
    const btns = (hit.extras?.buttons||[]).map(b=>{
      if (!b?.label) return '';
      const action = b.trigger || b.link || '';
      if (/^https?:\/\//i.test(action)) {
        return `<a href="${action}" target="_blank" class="pill-btn">${b.label}</a>`;
      }
      // bot√≥n que simula un "trigger" (env√≠a el texto)
      return `<button class="pill-btn chat-option" data-trigger="${action}">${b.label}</button>`;
    }).join("");
    const html = `${label}<div class="flex flex-wrap gap-2">${btns}</div>`;
    delayedAssistantAction(() => addAssistantMessageHTML(html, { avatarUrl: CURRENT.avatarUrl }), delayMs, delayOpts);
    return true;
  }

  return false;
}

/* Delegaci√≥n para botones de men√∫ (menu->trigger) */
document.addEventListener('click', (e)=>{
  const b = e.target.closest('.chat-option');
  if (!b) return;
  const trig = (b.dataset.trigger||'').trim();
  if (!trig) return;
  // Muestra como si el usuario hubiera escrito
  addUserMessage(trig);
  handleUserMessage(trig);
  maybePromptLeadCaptureAI();
});

document.addEventListener('click', (event) => {
  const leadBtn = event.target.closest('.lead-option');
  if (!leadBtn) return;
  const action = (leadBtn.dataset.leadAction || '').trim();
  if (!action) return;
  handleLeadOption(action);
});

/* =========================
   WELCOME (desde config/chatWelcome)
========================= */
function scheduleWelcome(){
  const key = `welcomeOnce_${EMPRESA}_${BOT}`;
  if (sessionStorage.getItem(key)) return;
  const ref = eref('config/chatWelcome');
  ref.once('value').then(s=>{
    const val = s.val() || {};
    if (!val.enabled) return;
    const delay = Math.max(0, parseInt(val.delay||2));
    setTimeout(()=>{
      const parts=[];
      if (val.image) parts.push(`<img src="${val.image}" class="w-full max-w-xs rounded-lg mb-2" />`);
      if (val.text) parts.push(marked.parse(val.text));
      const html = parts.join("");
      delayedAssistantAction(() => {
        addAssistantMessageHTML(html, { avatarUrl: CURRENT.avatarUrl });
        sessionStorage.setItem(key, '1');
      });
    }, delay*1000);
  });
}

/* =========================
   IA: MENSAJER√çA
========================= */
const MESSAGES = []; // {role:'system'|'user'|'assistant', content:string}
const CURRENT = { avatarUrl: "", hotelName: "", contextInfo: "", personality:"warm" };


async function askAI(userText) {
  const combinedSystem = `
  ${SYSTEM_PROMPT || ""}

  Use the following hotel information to answer the guest accurately:

  ${CURRENT.contextInfo || ""}
  `;

  const body = {
    messages: MESSAGES,
    system: combinedSystem
  };

  const res = await fetch(PROXY_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });

  if (!res.ok) throw new Error("IA request failed: " + res.status);
  const data = await res.json();
  return data?.choices?.[0]?.message?.content || "";
}

async function detectLeadIntent(conversation) {
  const prompt = `
    Analiza la siguiente conversaci√≥n entre un usuario y un asistente.
    Debes detectar si el usuario muestra intenci√≥n de compra o contacto comercial:
    - reservar
    - pedir precios o cotizaci√≥n
    - solicitar informaci√≥n
    - pedir hablar con un humano
    - inter√©s en contratar
    - intenci√≥n de compra
    - o cualquier necesidad de contacto comercial

    Puede estar en cualquier idioma.

    Devuelve SOLO un JSON v√°lido con este formato exacto:

    {"lead": true}  (si el usuario muestra intenci√≥n de contacto/comercial)
    {"lead": false} (si no existe intenci√≥n)

    Conversaci√≥n:
    ${conversation}
  `;

  const res = await fetch(PROXY_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      messages: [{ role: "user", content: prompt }]
    })
  });

  const data = await res.json();
  try {
    return JSON.parse(data?.choices?.[0]?.message?.content || "{}").lead === true;
  } catch {
    return false;
  }
}

async function handleUserMessage(text){
  // 1) AutoResponses (si hay match, responde y no llama IA)
  if (tryAutoResponse(text)) return;

  // 2) IA
  const typing = showTypingIndicator();

  try{
    const reply = await askAI(text);
    MESSAGES.push({ role:'assistant', content: reply });
    removeTyping(typing);
    addAssistantMessage(reply, { avatarUrl: CURRENT.avatarUrl });
  }catch(err){
    console.error(err);
    removeTyping(typing);
    addAssistantMessage("Lo siento, hubo un problema al responder. ¬øPuedes intentar nuevamente?");
  }
}

/* =========================
   SEND (bot√≥n y Enter)
========================= */
async function sendNow(){
  const t = (input.value || "").trim();
  if (!t) return;
  addUserMessage(t);
  input.value = "";
  if (processLeadCaptureInput(t)) {
    return;
  }
  const leadDetected = await maybePromptLeadCaptureAI(t);
  if (leadDetected === true) {
    return;
  }
  MESSAGES.push({ role:'user', content:t });
  handleUserMessage(t);
}
sendBtn.addEventListener('click', sendNow);
input.addEventListener('keydown', e=>{ if(e.key === 'Enter'){ e.preventDefault(); sendNow(); }});

function setChatMenuVisibility(show) {
  if (!chatMenu) return;
  const shouldShow = Boolean(show);
  if (shouldShow) {
    chatMenu.classList.remove('hidden');
    chatMenuBtn?.setAttribute('aria-expanded', 'true');
  } else {
    chatMenu.classList.add('hidden');
    chatMenuBtn?.setAttribute('aria-expanded', 'false');
  }
}

function toggleChatMenu() {
  if (!chatMenu) return;
  const isHidden = chatMenu.classList.contains('hidden');
  setChatMenuVisibility(isHidden);
}

function formatConversationTimestamp(time) {
  const date = new Date(time);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  let hours = date.getHours();
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');
  const suffix = hours >= 12 ? 'PM' : 'AM';
  hours = hours % 12 || 12;
  const hh = String(hours).padStart(2, '0');
  return `${year}-${month}-${day} ${hh}:${minutes}:${seconds} ${suffix}`;
}

function buildConversationExport() {
  const lines = [];
  const hotelName = (CURRENT.hotelName || hotelNameEl?.textContent || 'Hotel assistant').trim();
  const startTime = conversationLog[0]?.time || Date.now();
  const visitorName = (typeof getChatUserName === 'function' ? getChatUserName() : 'Visitor') || 'Visitor';
  lines.push(`Conversation with ${hotelName}`);
  lines.push(`Started on ${new Date(startTime).toUTCString()}`);
  lines.push('');

  conversationLog.forEach(entry => {
    const timestamp = formatConversationTimestamp(entry.time);
    const senderLabel = entry.sender === 'bot' ? 'Chatbot' : visitorName;
    const message = (entry.text || '').replace(/\r?\n/g, '\n    ');
    lines.push(`${timestamp} | ${senderLabel}: ${message}`);
  });

  return lines.join('\n');
}

function downloadConversation() {
  const content = buildConversationExport();
  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  const isoDate = new Date().toISOString().slice(0, 10);
  link.download = `conversation-${isoDate}.txt`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

if (chatMenuBtn) {
  chatMenuBtn.addEventListener('click', (event) => {
    event.stopPropagation();
    toggleChatMenu();
  });
}

if (downloadChatBtn) {
  downloadChatBtn.addEventListener('click', () => {
    try {
      downloadConversation();
    } finally {
      setChatMenuVisibility(false);
    }
  });
}

document.addEventListener('click', (event) => {
  if (!chatMenu || chatMenu.classList.contains('hidden')) return;
  if (chatMenu.contains(event.target)) return;
  if (chatMenuBtn && chatMenuBtn.contains(event.target)) return;
  setChatMenuVisibility(false);
});

document.addEventListener('keydown', (event) => {
  if (event.key === 'Escape') {
    setChatMenuVisibility(false);
  }
});

/* =========================
   CARGA DESDE FIREBASE (colores, logo, avatar, nombre, contexto, personality, autoResponses)
========================= */
function applyPrimaryColor(color){
  document.documentElement.style.setProperty('--chat-primary', color || '#111111');
}
function initFirebaseBindings() {
  // Colores
  eref('config/chatPrimaryColor').on('value', s => applyPrimaryColor(s.val() || '#111111'));

  // üÜï Fondo del chat
  eref('config/chatBackgroundColor').on('value', s => {
    const bg = s.val() || '#ececec';
    const chatWin = document.getElementById('chatWindow');
    if (chatWin) chatWin.style.background = bg;

    // Opcional: tambi√©n el body si el chat ocupa toda la pantalla
    document.body.style.background = bg;
  });
  
// üü£ Header Background Color
eref('config/chatHeaderColor').on('value', s => {
  const h = s.val() || '#ffffff';
  const chatHeader = document.getElementById('chatHeader');
  if (chatHeader) chatHeader.style.background = h;
});

// üü¶ Header Text Color
eref('config/chatHeaderTextColor').on('value', s => {
  const c = s.val() || '#1f2937';
  document.documentElement.style.setProperty('--chat-header-text', c);
});

// üü¢ Assistant Text Color
eref('config/chatAssistantTextColor').on('value', s => {
  const c = s.val() || '#000000';
  const msgs = document.querySelectorAll('.chat-assistant .msg');
  msgs.forEach(m => m.style.color = c);
  // Guarda el color actual para los nuevos mensajes
  document.documentElement.style.setProperty('--assistant-text', c);
});


// üü† Client Text Color
eref('config/chatClientTextColor').on('value', s => {
  const c = s.val() || '#ffffff';
  document.documentElement.style.setProperty('--chat-client-text', c);
  document.querySelectorAll('.chat-user').forEach(m => { m.style.color = c; });
});


// üü° Avatar en tiempo real
eref('config/avatarUrl').on('value', s => {
  const url = s.val() || '';
  CURRENT.avatarUrl = url;
  // Actualiza avatares visibles
  document.querySelectorAll('.avatar-icon').forEach(img => {
    if (url) img.src = url;
  });
});


  // Header hotel name
  eref('config/hotelName').on('value', s => {
    CURRENT.hotelName = s.val() || '';
    if (CURRENT.hotelName) hotelNameEl.textContent = CURRENT.hotelName;
  });

  // Logo + radio
  const logoRef = eref('config/logoUrl');
  const radiusRef = eref('config/logoRadius');
  let logoUrl = "";
  let logoRadius = 50;
  const applyLogo = () => {
    if (logoUrl) {
      chatLogo.src = logoUrl;
      chatLogo.style.borderRadius = `${logoRadius}%`;
      chatLogo.classList.remove('hidden');
    } else {
      chatLogo.classList.add('hidden');
      chatLogo.removeAttribute('src');
    }
  };
  logoRef.on('value', s => { logoUrl = s.val() || ""; applyLogo(); });
  radiusRef.on('value', s => { logoRadius = s.val() || 0; applyLogo(); });

  // Avatar
  eref('config/avatarUrl').on('value', s => {
    CURRENT.avatarUrl = s.val() || "";
  });

  const applyAvatarRadius = (value) => {
    const numeric = typeof value === 'number' ? value : parseInt(value, 10);
    const radius = Number.isFinite(numeric) ? Math.min(50, Math.max(0, numeric)) : 50;
    document.documentElement.style.setProperty('--avatar-radius', `${radius}%`);
  };

  applyAvatarRadius(50);
  eref('config/avatarRadius').on('value', s => {
    applyAvatarRadius(s.val());
  });

  // üÜï Tipograf√≠a din√°mica completa
  eref('config/fontFamily').on('value', s => {
    const f = s.val() || 'Manrope';

    // Lista de fuentes soportadas en Google Fonts
    const available = [
      "Manrope", "Inter", "Poppins", "Roboto", "Playfair Display", "Merriweather"
    ];

    // Solo intentar cargar si est√° en la lista
    if (available.includes(f)) {
      const id = `font_${f.replace(/\s+/g, '')}`;
      if (!document.getElementById(id)) {
        const link = document.createElement('link');
        link.id = id;
        link.rel = 'stylesheet';
        link.href = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(f)}:wght@400;500;600;700&display=swap`;
        document.head.appendChild(link);
      }
    }

    // Aplica siempre el font-family (aunque no se haya cargado)
    document.body.style.fontFamily = `'${f}', system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
  });

  // üß† Context info + personality (con actualizaci√≥n del system prompt)
  eref('config/contextInfo').on('value', s => {
    CURRENT.contextInfo = s.val() || "";

    // üß© Si ya existe el mensaje del sistema, actual√≠zalo
    if (MESSAGES.length > 0 && MESSAGES[0].role === 'system') {
      MESSAGES[0].content = buildSystemPrompt();
    }
  });

  eref('config/personality').on('value', s => {
    CURRENT.personality = s.val() || "warm";

    // üß© Actualizar tambi√©n el prompt si cambia la personalidad
    if (MESSAGES.length > 0 && MESSAGES[0].role === 'system') {
      MESSAGES[0].content = buildSystemPrompt();
    }
  });

  // AutoResponses
  eref('config/autoResponses').on('value', s => { AUTO = s.val() || {}; });

  // Welcome
  scheduleWelcome();
}


/* =========================
   INICIO
========================= */
/* =========================
   INTEGRACI√ìN CON embed.js (versi√≥n estable y limpia)
========================= */
function initEmbedIntegration() {
  window.addEventListener("message", (e) => {
    if (!e.data || typeof e.data !== "object") return;
    const { action } = e.data;

    if (action === "getChatButtonIcon") {
      if (typeof eref !== "function") {
        console.warn("eref no disponible a√∫n");
        return;
      }

      Promise.all([
        eref("config/widgetIcon").once("value"),
        eref("config/widgetRadius").once("value")
      ]).then(([iconSnap, radiusSnap]) => {
        const iconPath = iconSnap.val() || "";
        const radius = radiusSnap.val() || 0;

        if (iconPath) {
          const fullUrl = iconPath.startsWith("http")
            ? iconPath
            : `https://tomos.bot/${iconPath}`;

          window.parent.postMessage(
            { action: "chatButtonIcon", imageUrl: fullUrl, radius },
            "*"
          );
        } else {
          const svg = `
            <svg xmlns="http://www.w3.org/2000/svg" fill="none"
              viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M7 8h10M7 12h6m-6 4h8m-5 8c-1.654 0-3-.346-3-1v-1.691
                c-3.771-1.466-6-4.718-6-8.309C1 5.373 5.373 1 11 1s10 4.373
                10 9c0 3.591-2.229 6.843-6 8.309V21c0 .654-1.346 1-3 1z"/>
            </svg>`;

          window.parent.postMessage(
            { action: "chatButtonIcon", svg, radius },
            "*"
          );
        }
      });
    }

    if (action === "getChatButtonStatus") {
      window.parent.postMessage(
        { action: "chatButtonStatus", visible: true },
        "*"
      );
    }

    if (action === "openChatWindow") {
      const w = document.getElementById("chatWindow");
      if (w) w.style.display = "flex";
    }
  });

  window.parent.postMessage({ action: "chatReady" }, "*");

  if (typeof eref === "function") {
    eref("config/chatButtonColor").on("value", (s) => {
      const color = s.val() || "#111111";
      window.parent.postMessage(
        { action: "updateChatButtonColor", color },
        "*"
      );
    });
  }
}

/* =========================
   INICIO GLOBAL (espera Firebase y luego integra embed.js)
========================= */
document.addEventListener("DOMContentLoaded", async () => {
  lucide.createIcons();
  await prepareBotPath();
  initSystemPromptListener();
  initFirebaseBindings();

  // Cerrar chat
  document.getElementById("closeChat").addEventListener("click", () => {
    try {
      if (window.parent !== window)
        window.parent.postMessage({ action: "closeChatWindow" }, "*");
    } catch (e) {}
  });

  // Iniciar integraci√≥n con embed.js despu√©s que Firebase est√© listo
  const tryInit = () => {
    if (typeof firebase !== "undefined" && typeof eref === "function") {
      initEmbedIntegration();
    } else {
      console.warn("‚è≥ Esperando Firebase para integraci√≥n...");
      setTimeout(tryInit, 600);
    }
  };
  tryInit();
});


  </script>

</body>
</html>
